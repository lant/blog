---
layout: post
title: La màquina virtual de java (I)
date: '2010-05-25T07:16:00.002+01:00'
author: Marc de Palol
tags:
- rendiment
- memòria
- java
modified_time: '2010-05-25T07:32:11.082+01:00'
blogger_id: tag:blogger.com,1999:blog-6541464271719475452.post-6763333307592412532
blogger_orig_url: http://distribuint.blogspot.com/2010/05/la-maquina-virtual-de-java-i.html
---

<div>Aquests últims dies he estat intentant informar-me de quines són les millor tècniques per optimitzar processos Java. Hi ha molta informació a la web, la majoria està a la pàgina oficial de <strike>Sun</strike> Oracle. </div><div><br /></div><div>He intentat fer un petit resum per si a algú li interessa. Lògicament és una petita introducció amb molts de links a les pàgines amb la documentació oficial. </div><div><br /></div><div>Primer, unes consideracions sobre optimitzacions i "benchmarks" que crec que són importants: </div><div><br /></div><div>Java SE 6 no va introduïr moltes novetats pel que fa a la API. Bàsicament és una actualització que atacava la performance de Java. Podem veure algunes gràfiques comparant els diferents rendiments a [<a href="http://java.sun.com/performance/reference/whitepapers/6_performance.html#2.3">7</a>]. Per tant, és important que ens assegurem que sempre tinguem la última versió de Java instal·lada al sistema. Un altre tema és que la informació que trobareu aquí parla exclusivament de la VM Hotspot (de Sun). Hi ha altres VM, amb altres rendiments, com podeu veure a [<a href="http://www.usenix.org/event/jvm02/full_papers/jacob/jacob_html/node12.html">8</a>].</div><div><br /></div><div>En quant a les monitoritzacions, sempre que provem alguna cosa cal que les dades i l'estat de la màquina sigui el mateix. Tot i això en java cal tenir en compte: </div><div><br /></div><div><ul><li><b>Warmup: </b>La JVM funciona interpretant codi compil·lat. Segons la modalitat en que s'estigui executant (<i>client</i> o <i>server</i>) detectarà mètodes hot (que s'usen molt sovint) i els compilarà a codi natiu de la màquina per millorar-ne el temps d'execució. Això fa que el rendiment millori a mesura que s'executa el programa.</li><li><b>Garbage collection (GC):</b> He pogut comprovar que la majoria de tècniques d'optimització en Java tenen a veure amb la gestió del GC i de la memòria. Malauradament el tema és molt complexe i es mereix un post ( o un llibre ) per si sól.</li><li><b>Mesurament de temps:</b> En cas de que volguem pendre mesures de temps del programa i que no tinguem un profiler a mà Java ofereix dues crides que retornen temps. Es veu però que la <span class="Apple-style-span"  style="font-family:'courier new';">System.currentTimeMillis()</span> no és del tot fiable (sobretot en sistemes operatius Windows) i es recomana utilitzar la <span class="Apple-style-span"  style="font-family:'courier new';">System.nanoTime()</span>.</li></ul></div><div>Finalment tenim la interpretació de resultats. No hi ha prou en executar-lo una vegada. Si es pot s'hauria de fer un anàlisi estadístic (més sobre tot això en un pròxim post). </div><div><br /></div><div>Un cop feta la introducció al tema, comentaré alguns dels links més interessants que he trobat: </div><div><br /></div><div>Java Tuning Whitepaper [<a href="http://java.sun.com/performance/reference/whitepapers/tuning.html">1</a>], tot i que sigui del 2005, és un molt bon recurs introductori. Molt genèric i fàcil d'entendre. Com ja he dit abans, bàsicament es parla de memòria i de GC.</div><div><br /></div><div>La màquina virtual de Java té les opcions que formen part dels <i>Ergonomics</i>, que són les opcions que permeten modificar el comportament a l'hora d'executar els divesos programes, les opcions més conegudes són:</div><div><ul><li><b>Xms:</b> La quantitat de memòria inicial del programa. Si no donem una mida inicial aquesta serà de 2 Mb.</li><li><b>Xmx:</b> La quantitat màxima de memòria que la màquina virtual estarà permesa a utilitzar.</li></ul></div><div>Lògicament, hem de vigilar a l'hora d'asignar aquests valors, ja que influiran molt en el rendiment del programa, com més memòria millor, ara bé, com més memòria més haurà de treballar el GC i menys quedarà pel sistema operatiu, cosa que pot ocasionar que el rendiment general del sistema es vegi perjudicat. </div><div><br /></div><div>Algunes opcions relacionades amb el GC [<a href="http://java.sun.com/docs/hotspot/gc5.0/gc_tuning_5.html">2</a>]:</div><div><ul><li>The -XX:+UseParallelGC parallel (throughput) garbage collector.</li><li>The -XX:+UseConcMarkSweepGC concurrent (low pause time) garbage collector (also known as CMS)</li><li>The -XX:+UseSerialGC serial garbage collector (for smaller applications and systems)</li></ul></div><div>Una de les opcions que no coneixia d'abans és la de canviar la mida de les pàgines de memòria, bàsicament modificarem la mida de la <a href="http://en.wikipedia.org/wiki/Translation_lookaside_buffer">TLB</a> (Translation-Lookaside Buffer) que és la part de memòria que manté les traduccions de memòria virtual a memòria física. Ampliant la mida de les pàgines també ampliarem la mida de la TLB, i per tant seran menys fallades a l'hora de buscar adreces de memòria. Pot millorar l'eficiència d'aplicacions que utilitzin molta memòria. Cal tenir en compte que es pot afectar negativament l'eficiència del sistema, ja que l'aplicació pot fer un us execessiu de memòria fent que la resta del sistema es quedi curt, a més no és fàcil de configurar (s'ha de fer canvis a nivell del SO) podeu trobar instruccions aquí [<a href="http://java.sun.com/javase/technologies/hotspot/largememory.jsp">3</a>].</div><div><br /></div><div>I més opcions llistades a [<a href="http://java.sun.com/javase/technologies/hotspot/vmoptions.jsp#PerformanceTuning">4</a>], de les quals destacaria:</div><div><ul><li><b>XX:+UseFastAccessorMethods:<span class="Apple-style-span" style="white-space: pre;"> </span></b>Use optimized versions of Get<primitive>Field.</primitive></li><li><primitive></primitive><b>XX:+StringCache<span class="Apple-style-span" style="white-space: pre;">: </span></b>Enables caching of commonly allocated strings.</li></ul></div><div>El document també té una secció molt interessant amb exemples explicats [<a href="http://java.sun.com/performance/reference/whitepapers/tuning.html#section4.2">5</a>].</div><div><br /></div><div>Finalment us deixo una llista de links bastant interessants sobre la JVM:</div><div><br /></div><div><span class="Apple-style-span" style="font-size: x-large;">Referències.</span></div><div><br /></div><div>[1] <a href="http://java.sun.com/performance/reference/whitepapers/tuning.html">http://java.sun.com/performance/reference/whitepapers/tuning.html</a></div><div>[2] <a href="http://java.sun.com/docs/hotspot/gc5.0/gc_tuning_5.html">http://java.sun.com/docs/hotspot/gc5.0/gc_tuning_5.html</a></div><div>[3]<a href="http://java.sun.com/javase/technologies/hotspot/largememory.jsp"> http://java.sun.com/javase/technologies/hotspot/largememory.jsp</a></div><div>[4] <a href="http://java.sun.com/javase/technologies/hotspot/vmoptions.jsp#PerformanceTuning">http://java.sun.com/javase/technologies/hotspot/vmoptions.jsp#PerformanceTuning</a></div><div>[5] <a href="http://java.sun.com/performance/reference/whitepapers/tuning.html#section4.2">http://java.sun.com/performance/reference/whitepapers/tuning.html#section4.2</a><span class="Apple-tab-span" style="white-space:pre"> </span></div><div>[6] <a href="http://java.sun.com/performance/reference/whitepapers/6_performance.html">http://java.sun.com/performance/reference/whitepapers/6_performance.html</a></div><div>[7] <a href="http://java.sun.com/performance/reference/whitepapers/6_performance.html#2.3">http://java.sun.com/performance/reference/whitepapers/6_performance.html#2.3</a></div><div>[8] <a href="http://www.usenix.org/event/jvm02/full_papers/jacob/jacob_html/node12.html">http://www.usenix.org/event/jvm02/full_papers/jacob/jacob_html/node12.html</a></div><div><br /></div>