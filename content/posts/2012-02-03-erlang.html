---
layout: post
title: Erlang
date: '2012-02-03T14:58:00.002Z'
author: Marc de Palol
tags:
- erlang
modified_time: '2012-02-03T14:58:55.202Z'
blogger_id: tag:blogger.com,1999:blog-6541464271719475452.post-4328575486089331632
blogger_orig_url: http://distribuint.blogspot.com/2012/02/erlang.html
---

<br />Hoy voy a escribir sobre lo que me ha mantenido ocupado en mis pocos ratos libres estos últimos meses, <b>Erlang</b>!<br /><br />Hace tiempo que quería aprender algo nuevo, lógicamente que me fuera útil y que estuviera relacionado con los sistemas distribuidos y la escalabilidad, faltaría más. Así que me puse a buscar y di con 3 buenas opciones:<br /><br /><ul><li><b>node.js</b></li><li><b>scala</b></li><li><b>erlang</b></li></ul><br />Me gustó mucho <b>node.js</b>, pero debo admitir que el hecho de que sea javascript me hechó un poco para atrás (aclaración: no tengo NADA en contra de javascript, pero no es exactamente lo que estaba buscando). Así que estaba entre <b>scala</b> i <b>erlang</b>.<br /><br /><span style="font-size: large;">Erlang vs Scala</span><br /><br />Por un lado tenemos un lenguaje de programación que corre en la máquina virtual de Java, actual, con toques funcionales y bastante hype, <a href="http://beust.com/weblog/2011/02/23/from-scala-back-to-java/">aunque no falto de críticas</a>. Por el otro lado un lenguaje mucho más "underground", totalmente funcional y bastante más viejo. Los dos se adaptan bien a lo que quería, y además, los dos tienen un modelo de concurrencia basado en <a href="http://en.wikipedia.org/wiki/Actor_model">"actores"</a>.<br /><br />Debo admitir que ya iba un poco predeterminado a escoger Erlang, aunque por temas de trabajo también me interesaba aprender un poco de Scala. Finalmente, tras unas pequeñas investigaciones y una pequeña incursión en Scala llegué a la conclusión de que el lenguaje es (para mi gusto) excesivamente complicado, no para aprender, sino ya para utilizar efectivamente, lo que en inglés llaman "overenginered". Lógicamente es una opinión personal.<br /><br />Así que nada, eché una ojeada a Erlang (<a href="http://www.learnyousomeerlang.com/">http://www.learnyousomeerlang.com</a>) y finalmente me decidí a comprar el libro de <a href="http://shop.oreilly.com/product/9780596518189.do">o'reilly</a>.<br /><br /><span style="font-size: large;">Erlang</span><br />Erlang es un lenguaje puramente funcional, con una sintaxis un poco barroca, que corre sobre una máquina virtual. Fue creado hace bastante tiempo (en términos informáticos) en Ericsson y fue abierto al público en 1998. No quiero ni describir el lenguaje ni hacer un mini tutorial, para esto tenéis la página que he puesto antes y la descripción en <a href="http://en.wikipedia.org/wiki/Erlang_(programming_language)">wikipedia</a>.<br /><br />Y qué pinta Erlang hoy en día ? pues básicamente su modelo de concurrencia, como he dicho antes, basado en actores, o lo que es lo mismo, un modelo de concurrencia sin variables compartidas, mediante envío de mensajes, asíncrono.<br /><br /><span style="font-size: large;">Pero hay alguien que utilice Erlang?</span><br />Pues si señores, seguro que os suenan estos proyectos (entre muchos otros):<br /><br /><ul><li><a href="http://couchdb.apache.org/">couchdb</a>: Base de datos Nosql.&nbsp;</li><li><a href="http://wiki.basho.com/Riak.html">riak</a>: idem</li><li><a href="https://github.com/mochi/mochiweb">mochiweb</a>: Servidor HTTP asíncrono.</li></ul><br /><span style="font-size: large;">Temas que hacen que erlang sea la caña:</span><br />Como ya he dicho no quiero entrar en detalle del funcionamiento de Erlang, ni de la sintaxis ni de las características del lenguaje, pero hay unos temas que me creo hay que destacar:<br /><br /><ul><li><b>Asíncrono con envío de mensajes</b>: Las comunicaciones entre procesos se hacen a base de enviar mensajes. Los procesos van realizando sus tareas y de vez en cuando miran su "mailbox", si hay algun mensaje, se lee y se hace lo que se tiene que hacer y se contesta.&nbsp;</li><li><b>Hot code swapping</b>: Uno de las características más espectaculares. Podemos hacer un update de código sin tener que reiniciarlo. No es eso el sueño de todo programador de backend?</li><li><b>Programación distribuida integrada</b>: Igual que las comunicaciones entre procesos, pero en procesos en máquinas distintas, todo integrado en el 'core' del lenguaje, sin ningún tipo de librería externa.</li><li><b>Película</b>: si señores, Erlang tiene una <a href="http://www.archive.org/details/ErlangTheMovie">película</a>.</li></ul><br />Además, hay algunos links dignos de mención:<br /><br /><ul><li><a href="http://blog.whatsapp.com/index.php/2011/09/one-million/">Un milión de conexiones con una sóla máquina en Whatsapp</a>.</li><li><a href="http://blog.whatsapp.com/index.php/2012/01/1-million-is-so-2011/">Nah, que sean dos millones</a>.&nbsp;</li><li><a href="http://www.facebook.com/note.php?note_id=14218138919">Sistema de chat de Facebook</a>.&nbsp;</li></ul><br /><br /><span style="font-size: large;">Del tutorial a producción</span><br /><br />El hecho de que sea un lenguaje muy distinto de los que estoy acostumbrado a trabajar hace que sea un poco difícil de dominar, ya se sabe, para aprender hay que poner horas y experiencia, en términos informáticos: poner en producción. Intenté convencer a unos compañeros de un proyecto para utilizar Erlang, su respuesta fue que como vieran una sola linea de Erlang en el sistema me iban a colgar de lo más alto <a href="http://upload.wikimedia.org/wikipedia/commons/thumb/b/b2/Clock_Tower_-_Palace_of_Westminster%2C_London_-_September_2006-2.jpg/200px-Clock_Tower_-_Palace_of_Westminster%2C_London_-_September_2006-2.jpg">de un edificio muy conocido</a>, así que de momento me estoy reservando a algún proyecto personal que ya tengo pensado y muy pronto (crucemos los dedos) empezaré.<br /><div><br /></div>